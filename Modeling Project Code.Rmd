---
title: "COVID Modeling Project"
author: "Trust Okorie"
date: "6/16/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggplot2)
```

```{r}
s <- c(200)
i <- c(1)
r <- c(0)
N <- 201
beta <- .4
gamma <- .2

## S -> I -> R
for (t in 2:100){
  new_infs <- beta * i[t-1] * s[t-1]/ N
  new_recover <- gamma * i[t-1] 
  s[t] <- s[t-1] - new_infs
  i[t] <- i[t-1]  + new_infs  - new_recover
  r[t] <- r[t-1] + new_recover
}
```

```{r}
plot_data <- data.frame(i=i,s=s,r=r,t=1:100)
ggplot(plot_data,aes(x=t,y=i)) + geom_line(color='red') +
  geom_line(aes(x=t,y=s),color='blue')+  geom_line(aes(x=t,y=r),color='green')
```

```{r}
# Agent Based Modeling

# Set number of agents and create agent dataframe
# Create variables for infection chance (beta) and recovery chance (gamma)
n_agents <- 100

# How many secondary infections at each time step
beta = 1.5 * .1
# Hopw long agent is infected until recovery
gamma = .8 * .1
agents <- data.frame("Agent" = 1:n_agents, "State" = "S", "TimeOfPrimaryInfection" = NA, 
                     "TimeToSecondaryInfection" = NA, "InfectionChance" = beta, "RecoveryChance" = gamma)

# Patient Zero
agents[1,]$State = "I"
agents[1,]$TimeOfPrimaryInfection = 1

# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2365921/
# Generation Interval contracts as number of susceptibles decreases
# We are using the first agent and simulating infection some number of times 
# Each agent has a uniform distribution 
# Function that iterates through agent data frame and infects agents based on infection chance
agents.infect <- function(agents, t){
  for (i in 1:nrow(agents)){
    if (agents[i,]$State == "I"){
      for (j in 1:nrow(agents)){
        if (agents[j,]$State == "S"){
          # Is ContactChance greater than or less than beta?
          if (beta > runif(1,0,1)){
            #agents[j,]$State = "I"
            # If agent is infected, record the time of this infection and assign it to 
            # the primary infection variable
            agents[j,]$TimeOfPrimaryInfection = t
            # If an agent is infected by another agent, record the time of this secondary infection and assign
            # it to the secondary infection variable
            # Calculate time units it takes for secondary infection to occur
            # Secondary infection time may be overwritten in loop
            # Last infection of secondary infection is the output
            # Keep track of ALL secondary infections for each infected agent
            # Keep track of every infection event (generation interval)
            # num_elements tells us how many elements in the list (number of samples from generation intervals)
            # Adding a new sample from generation interval
            gen_int_list[[length(gen_int_list) + 1]] <<- (t - agents[i,]$TimeOfPrimaryInfection)
          }
        }
      }
    }
  }
  return(agents)
}


# Function that iterates through agent data frame and recovers infected agents based on recovery chance
agents.recover <- function(agents, t){
  for (i in 1:nrow(agents)){
    if (agents[i,]$State == "I"){
      # Is RecoveryChance greater than or less than gamma?
      if(gamma > runif(1,0,1)){
        agents[i,]$State = "R"
        recovery_dist[[length(recovery_dist) + 1]] <<- (t) 
      }
    }
  }
  return(agents)
}


# Function that simulates the infection and recovery of agents throughout time
agents.simulate <- function(agents){
  I <- c(1)
  for (t in 1:100){
    agents <- agents.infect(agents, t)
    agents <- agents.recover(agents, t)
    I <- c(I, nrow(agents[agents$State == "I",]))
  }
  return_list <- list()
  return_list[[1]] <- agents
  return_list[[2]] <- I
  return(return_list)
}

# Run all functions and simulate movement of agents
# Assign simulated values to variables in data frame

recovery_dist <- list()
gen_int_list <- list()
for (nsim in 1:500){
  agents <- data.frame("Agent" = 1:n_agents, "State" = "S", "TimeOfPrimaryInfection" = NA)
  # Patient Zero
  agents[1,]$State = "I"
  agents[1,]$TimeOfPrimaryInfection = 1
  return_list <- agents.simulate(agents)
  agents <- return_list[[1]]
  I <- return_list[[2]]
}

# Include Time variable
# Figure out way to keep track of primary and secondary infection times
# Add times to the data frame

# We want empirical mean to equal 1/gamma ex. 1/.33 = 33
# A matter of math behind our model than the model itself
# Generation interval is distribution of time to recovery
# Our stochastic implementation violates this assumption (there is a constant rate of secondary infection contacts)

# Find way to keep rate of infection constant
```

```{r}
plot(I)
gen_interval <- unlist(gen_int_list)
hist(gen_interval)

# Time to recovery distribution is the same because each individual has a
recovery_int <- unlist(recovery_dist)
hist(recovery_int)

# We want mean generation interval to be close to 1/gamma becasue gamma determines time until recovery
# This means the generation interval distribution is equivalent to time to recovery
mean(gen_interval)
```

```{r}
# Contact Network Structure - Adjacency Matrix
# Tip: start with "random graph", connections between people with random probability p
# If p = 1, connect two people, if p = 0, they do not connect

# Matrix ith row and jth column should have 1 if person i is connected to person j
network_matrix <- matrix(0, 100, 100)

# if agent at i is connected to agent at j, continue infect function
```
